// Copyright 2023 Intrinsic Innovation LLC

syntax = "proto3";

package intrinsic_proto.scene_object.v1;

import "intrinsic/kinematics/types/joint_limits.proto";
import "intrinsic/math/proto/pose.proto";
import "intrinsic/scene/proto/v1/object_properties.proto";

// Similar to SceneObjectUpdate but restricted in the types of updates that can
// be performed.
message SceneObjectInstanceUpdate {
  // The type of update to apply.
  oneof update {
    EntityPoseUpdate entity_pose = 1;
    CreateFrameUpdate create_frame = 2;
    // Only allowed to delete frames.
    DeleteEntityUpdate delete_entity = 3;
    SetNamedConfigurationsUpdate set_named_configurations = 4;
    UpdateJointsRequest update_joints = 5;
    CartesianLimitsUpdate cartesian_limits = 6;
    RenameEntityUpdate rename_entity = 7;
  }
}

// A list of updates to apply to a scene object instance.
message SceneObjectInstanceUpdates {
  // The updates to apply in order.
  repeated SceneObjectInstanceUpdate updates = 1;
}

message EntityPoseUpdate {
  // The name of the entity being updated.
  string entity_name = 1;

  // The new pose of this entity relative to its parent.
  intrinsic_proto.Pose parent_t_this = 2;
}

// Create a new frame based entity with the given parameters.
message CreateFrameUpdate {
  // The entity under which the frame shall be created. If the name is empty we
  // will create the new frame under root. If the name cannot be found this will
  // result in an error.
  string parent_name = 1;

  // Name of the new frame entity to be created.
  string new_frame_name = 2;

  // Pose of the frame in the space of the parent entity's origin.
  intrinsic_proto.Pose parent_t_new_frame = 3;

  // We can optionally mark this frame as an attachment frame when creating it.
  bool designate_as_attachment_frame = 4;
}

message DeleteEntityUpdate {
  // The entity to be deleted.
  string entity_name = 1;

  enum ChildPolicy {
    // Same as CHILD_POLICY_FAIL_IF_PRESENT.
    CHILD_POLICY_UNSPECIFIED = 0;
    // If the entity has children we will fail to delete it.
    CHILD_POLICY_FAIL_IF_PRESENT = 1;
    // If the entity has children we will delete them all recursively down.
    CHILD_POLICY_DELETE_RECURSIVELY = 2;
    // If the entity has children, they will be reparented to the parent of the
    // deleted entity maintaining the same pose to it as is currently set. If we
    // have a chain of entities A -> B -> C, and B -> D, where A is the parent
    // of B and B is the parent of C and D. When we delete B with this setting,
    // we will reparent C and D to A and maintain the same A_t_C and A_t_D poses
    // as was present before the delete.
    CHILD_POLICY_REPARENT_CHILDREN = 3;
  }
  // Specify what to do with the children of the deleted entity if any exist.
  ChildPolicy child_policy = 2;
}

// Updates the named configurations on the scene object.
message SetNamedConfigurationsUpdate {
  // If set, this will clear all named configurations on the scene object.
  bool clear_all_named_configurations = 1;

  // The named configurations to remove from the scene object.
  repeated string named_configurations_to_remove = 2;

  // The named configurations to set on the scene object. If a named
  // configuration already exists with the same name, it will be overwritten.
  repeated NamedConfiguration named_configurations_to_set = 3;
}

// Updates the joint positions or limits on the scene object.
message UpdateJointsRequest {
  // If non-empty, new joint positions in degrees (for revolute joints) or
  // meters (for prismatic joints) that should be applied.  At least one
  // of 'joint_positions', 'joint_application_limits', 'joint_system_limits'
  // must be set.
  map<string, double> joint_positions = 1;

  // If non-empty, new joint application limits that should be applied. At least
  // one of 'joint_positions', 'joint_application_limits', 'joint_system_limits'
  // must be set.
  map<string, intrinsic_proto.JointLimitUpdate> joint_application_limits = 2;

  // If non-empty, new joint system limits that should be applied. At least one
  // of 'joint_positions', 'joint_application_limits', 'joint_system_limits'
  // must be set.
  map<string, intrinsic_proto.JointLimitUpdate> joint_system_limits = 3;
}

// Cartesian limits to use as overrides.
// If not set, the existing limits will be unchanged.
message CartesianLimitsUpdate {
  // Units are meters or radians per s, s^2, or s^3.
  repeated double min_translational_position = 1;
  repeated double max_translational_position = 2;
  repeated double min_translational_velocity = 3;
  repeated double max_translational_velocity = 4;
  repeated double min_translational_acceleration = 5;
  repeated double max_translational_acceleration = 6;
  repeated double min_translational_jerk = 7;
  repeated double max_translational_jerk = 8;

  optional double max_rotational_velocity = 9;
  optional double max_rotational_acceleration = 10;
  optional double max_rotational_jerk = 11;
}
message RenameEntityUpdate {
  // The entity to be renamed.
  string entity_name = 1;

  // The new name to give the entity.
  string new_entity_name = 2;
}
